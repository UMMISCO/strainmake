#!/usr/bin/env python3

# A CLI to compute the number of binned and not binned assemblies' contigs produced by the pipeline

import pyfastx
import os
import argparse
import pandas as pd
from tqdm import tqdm

def parse_arguments():
    parser = argparse.ArgumentParser(description='Count assembly contigs assigned to a bin.')

    parser.add_argument('--assembler', required=True, choices=['megahit', 'metaflye', 
                                                               'hybridspades', 'metaspades'], 
                        help='The assembly we should use')
    parser.add_argument('--results-dir', required=True, help="Folder storing the pipeline results. Typically named 'results': /path/to/pipeline/results")
    parser.add_argument('--type', required=True, choices=['binette', 'dereplicated_and_filtered'], help='Type of bins')
    parser.add_argument('--tsv_output_binned_contigs', required=True, help='File to save the list of contigs and their number of assignation in bins in TSV format')
    parser.add_argument('--tsv_output_binned_rate', required=True, help='File to save the binning rate of contigs in TSV format')

    return parser.parse_args()

def read_fasta(assembly_path: str):
    return pyfastx.Fasta(assembly_path, full_name=True)

def prepare_contigs_table(assembly: pyfastx.Fasta):
    """
    Returns a pandas Dataframe with assembly contigs in rows and a column 
    that will be used to count binned contigs

    The `assigned` column will contain the number of times a contig was assigned to
    a bin
    """

    # initializing an empty list to hold the contigs name
    contigs_name = []

    # iterating over the FASTA sequence to retrieve the contigs name
    for seq in assembly:
        seq_name = seq.name
        contigs_name.append({'contig': seq_name, 'assigned': 0, 
                             'len': len(seq.seq)})

    # Convert the list of dictionaries to a pandas DataFrame
    contigs_table = pd.DataFrame(contigs_name).sort_values(by="contig")

    return contigs_table

def compute_contigs_in_bins(bin_path: str, contigs_table: pd.DataFrame):
    """
    Extracts the contigs assigned to the bins and fill the contigs table 
    according to it
    """

    bin = read_fasta(bin_path)

    # for each contig of the bin, it adds 1 to the 'assigned' colum corresponding
    # to the contig
    for seq in bin:
        if seq.name in contigs_table['contig'].values:
            contigs_table.loc[contigs_table['contig'] == seq.name, 'assigned'] += 1
        else:
            print(f'Contig {seq.name} was not found in the contigs table')
            print('Please check that this contig pertains to the assembly')

    return contigs_table

def compute_contigs_for_all_bins(bins_directory: str, contigs_table: pd.DataFrame):
    """
    Computes the contigs assignation for each bins stored in the `bins_directory`
    folder
    """

    # listing all .fa files in bins_directory (= all bins)
    bin_files = [os.path.join(bins_directory, f) for f in os.listdir(bins_directory) if f.endswith('.fa')]

    # calculating contigs assignation
    for bin_path in tqdm(bin_files, desc="Processing bins"):
        contigs_table = compute_contigs_in_bins(bin_path, contigs_table)

        # deleting the index file generated by pyfastx
        index_file_path = bin_path + '.fxi'
        if os.path.exists(index_file_path):
            os.remove(index_file_path)

    return contigs_table

def compute_contigs_assignation_for_an_assembler(assembler: str, results_dir: str,
                                                 method_of_production: str):
    
    """
    `method_of_production`: "binette" or "dereplicated_and_filtered".
    It is used to guess where are the produced bins stored (after refinement
    for "binette" and after dereplication and filtration based on bin quality for 
    "dereplicated_and_filtered")
    """
    
    assemblies_dir = os.path.join(results_dir, "03_assembly")
    
    if assembler == "metaflye":
        assemblies_dir = os.path.join(assemblies_dir, "LR", "metaflye")
    elif assembler == "hybridspades":
        assemblies_dir = os.path.join(assemblies_dir, "hybridspades")
    elif assembler == "megahit":
        assemblies_dir = os.path.join(assemblies_dir, "megahit")
    elif assembler == "metaspades":
        assemblies_dir = os.path.join(assemblies_dir, "metaspades")

    # storing the results in a list
    contigs_table_list = []

    # iterating over each sample in the assemblies_dir
    for sample in os.listdir(assemblies_dir):
        sample_dir = os.path.join(assemblies_dir, sample)
        assembly_path = os.path.join(sample_dir, "assembly.fa.gz")
        
        # checking if the assembly file exists
        if os.path.exists(assembly_path):
            # reading the assembly
            assembly = read_fasta(assembly_path)

            # preparing the contigs table
            contigs_table = prepare_contigs_table(assembly)

            # adding a column with the sample id, it will be useful when we will concatenate
            # the dataframes
            contigs_table['sample'] = sample

            # defining the bins folder path based on the type
            if method_of_production == "binette":
                bins_folder = os.path.join(results_dir, "07_bins_refinement", "binette", assembler, sample, "final_bins") 
            elif method_of_production == "dereplicated_and_filtered":
                bins_folder = os.path.join(results_dir, "08_bins_postprocessing", "dereplicated_genomes_filtered_by_quality", assembler, "bins")

            # computing contigs assignation calculation
            if os.path.exists(bins_folder):
                contigs_table = compute_contigs_for_all_bins(bins_folder, contigs_table)

                contigs_table_list.append(contigs_table)
            else:
                print(f"No bins folder found at {bins_folder}")
        else:
            print(f'No assembly found for sample {sample}')

    return pd.concat(contigs_table_list, ignore_index=True)


def calculate_binned_contigs_rate(contigs_table: pd.DataFrame):
    """
    Calculates the percentage of binned contigs by sample
    """

    # Group by sample and calculate the rate of assigned contigs
    binned_contigs_rate = contigs_table.groupby('sample').apply(lambda df: (100 * (df['assigned'] > 0).sum() / len(df))).reset_index()

    # Rename columns for clarity
    binned_contigs_rate.columns = ['sample', 'binned_rate']

    return binned_contigs_rate


def main():
    args = parse_arguments()

    results = compute_contigs_assignation_for_an_assembler(args.assembler,
                                                           args.results_dir,
                                                           args.type)
    binned_contigs_rate = calculate_binned_contigs_rate(results)
    
    # exporting the results
    results.to_csv(args.tsv_output_binned_contigs, index=False, sep="\t")
    binned_contigs_rate.to_csv(args.tsv_output_binned_rate, index=False, sep="\t")

if __name__ == '__main__':
    main()